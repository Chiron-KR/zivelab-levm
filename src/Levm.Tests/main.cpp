// main.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <complex> 
#include <iostream>

#include "lib\levmar.h"

using namespace std;

#define TwoPi   6.2831853071795864769252867665590057683943387987502 // 2 * pi
#define OneOverSqrt2 0.70710678118654752440084436210484903928483593768847 // 1/sqrt(2)
#define OneOverTwoSqrtPi 0.28209479177387814347403972578038629292202531466450 // 1/(2*sqrt(pi))

#pragma region Define Rosenbrock
// f(x, y) = (a - x)^2 + b*(y - x^2)^2
// df/dx = -2 (a - 2 b x^3 + 2 b x y - x)
// df/dy = -2 b (x^2 - y)
// where a = 1.0, b = ROSD = 105.0
// it has a global minimum at (x, y) = (a, a^2)
#define ROSD 105.0
double rosenbrock_p[2] = { 1.0, 1.0 }; // best parameters
void rosenbrock(double *p, double *x, int m, int n, void *data)
{
	register int i;

    for (i = 0; i < n; ++i)
        x[i] = ((1.0 - p[0]) * (1.0 - p[0]) + ROSD * (p[1] - p[0] * p[0]) * (p[1] - p[0] * p[0]));
}
void rosenbrockprime(double *p, double *jac, int m, int n, void *data)
{
	register int i, j;

    for (i = j = 0; i < n; ++i) {
        jac[j++] = (-2 + 2 * p[0] - 4 * ROSD * (p[1] - p[0] * p[0]) * p[0]);
        jac[j++] = (2 * ROSD * (p[1] - p[0] * p[0]));
    }
}

#pragma endregion 

#pragma region Define Norris

// https://www.itl.nist.gov/div898/strd/lls/data/Norris.shtml

double norris_p[2] = { -0.262323073774029, 1.00211681802045 }; // best parameters
double norris_y[36] = {
	0.1,	338.8,	118.1,	888,	9.2,	228.1,	668.5,	998.5,	449.1,	778.9,	
	559.2,	0.3,	0.1,	778.1,	668.8,	339.3,	448.9,	10.8,	557.7,	228.3,	
	998,	888.8,	119.6,	0.3,	0.6,	557.6,	339.3,	888,	998.5,	778.9,	
	10.2,	117.6,	228.9,	668.4,	449.2,	0.2
};
double norris_x[36] = {
	0.2,	337.4,	118.2,	884.6,	10.1,	226.5,	666.3,	996.3,	448.6,	777,
	558.2,	0.4,	0.6,	775.5,	666.9,	338,	447.5,	11.6,	556,	228.1,
	995.8,	887.6,	120.2,	0.3,	0.3,	556.8,	339.1,	887.2,	999,	779,
	11.1,	118.3,	229.2,	669.1,	448.9,	0.5
};
void norris(double *p, double *y, int m, int n, void *data)
{
	register int i;
	for (i = 0; i < n; ++i)
		y[i] = p[0] + p[1] * norris_x[i];
}
void norrisprime(double *p, double *jac, int m, int n, void *data)
{
	register int i, j;

	for (i = j = 0; i < n; ++i) {
		jac[j++] = 1.0;
		jac[j++] = norris_x[i];
	}
}

#pragma endregion

#pragma region Define Lanczos1

// https://www.itl.nist.gov/div898/strd/nls/data/lanczos1.shtml
//

double lanczos1_p[6] = { 0.0951, 1.0, 0.8607, 3, 1.5576, 5 }; // best parameters
double lanczos1_y[24] = {
	2.513400000000,	2.044333373291,	1.668404436564,	1.366418021208,	1.123232487372,
	0.926889718004,	0.767933856373,	0.638877552311,	0.533783531740,	0.447936361735,
	0.377584788435,	0.319739319933,	0.272013077375,	0.232496552903,	0.199658954607,
	0.172270412691,	0.149340566017,	0.130070020692,	0.113811932464,	0.100041558756,
	0.088332090845,	0.078335440194,	0.069766937434,	0.062393125367
};
double lanczos1_x[24] = {
	0.000000000000,	0.050000000000,	0.100000000000,	0.150000000000,	0.200000000000,
	0.250000000000,	0.300000000000,	0.350000000000,	0.400000000000,	0.450000000000,
	0.500000000000,	0.550000000000,	0.600000000000,	0.650000000000,	0.700000000000,
	0.750000000000,	0.800000000000,	0.850000000000,	0.900000000000,	0.950000000000,
	1.000000000000,	1.050000000000,	1.100000000000,	1.150000000000
};
void lanczos1(double *p, double *y, int m, int n, void *data)
{
	register int i;

    double x;
    double *xx = (double*)data;    
	for (i = 0; i < n; ++i, xx++)
	{
		x = *xx;
		y[i] = p[0] * exp(-p[1] * x) + p[2] * exp(-p[3] * x) + p[4] * exp(-p[5] * x);
	}
}

#pragma endregion

#pragma region Define Thurber

// https://www.itl.nist.gov/div898/strd/nls/data/thurber.shtml
//

double thurber_p[7] = {
    1288.139680000000, 1491.079253500000, 583.238368770000, 75.416644291000, 0.966295028640,
    0.397972857970, 0.049727297349 }; // best parameters
double thurber_y[37] = {
	 80.574,	084.248,	087.264,	087.195,	089.076,	
	 089.608,	089.868,	090.101,	092.405,	095.854,
	 100.696,	101.060,	401.672,	390.724,	567.534,	
	 635.316,	733.054,	759.087,	894.206,	990.785,
	1090.109,	1080.914,	1122.643,	1178.351,	1260.531,
	1273.514,	1288.339,	1327.543,	1353.863,	1414.509,
	1425.208,	1421.384,	1442.962,	1464.350,	1468.705,
	1447.894,	1457.628
};
double thurber_x[37] = {
	-3.067,	-2.981,	-2.921,	-2.912,	-2.84,
	-2.797,	-2.702,	-2.699,	-2.633,	-2.481,
	-2.363,	-2.322,	-1.501,	-1.460,	-1.274,
	-1.212,	-1.100,	-1.046,	-0.915,	-0.714,
	-0.566,	-0.545,	-0.400,	-0.309,	-0.109,
	-0.103,	0.01,	0.119,	0.377,	0.79,
	0.963,	1.006,	1.115,	1.572,	1.841,
	2.047,	2.2
};
void thurber(double *p, double *y, int m, int n, void *data)
{
	register int i;

    double x;
	double *xx = (double*)data;
	for (i = 0; i < n; ++i, xx++)
	{
		x = *xx;
		y[i] = (p[0] + p[1] * x + p[2] * x*x + p[3] * x*x*x) / (1 + p[4] * x + p[5] * x*x + p[6] * x*x*x);
	}
}

#pragma endregion

#pragma region Define Rat43

// https://www.itl.nist.gov/div898/strd/nls/data/ratkowsky3.shtml

double rat43_p[4] = {
    699.641512700000,   5.277125302500, 0.759629383290, 1.279248385900
}; // best parameters
double rat43_y[15] = {
     16.08, 33.83,  65.80,  97.20,  191.55, 326.20, 386.87, 520.53, 590.03, 651.92,
    724.93, 699.56, 689.96, 637.56, 717.41
};
double rat43_x[15] = {
    1.00,   2.00,   3.00,   4.00,   5.00,   6.00,   7.00,   8.00,   9.00,   10.00,
    11.00,  12.00,  13.00,  14.00,  15.00
};
void rat43(double *p, double *y, int m, int n, void *data)
{
    register int i;

    double x;
    double *xx = (double*)data;
    for (i = 0; i < n; ++i, xx++)
    {
        x = *xx;
        y[i] = p[0] / pow(1.0 + exp(p[1] - p[2] * x), 1.0 / p[3]);
    }
}

#pragma endregion

#pragma region Define Randle - Rs-Rct|Cdl

// Model Expression = Rs-Rct|Cdl
// Z = Rs + 1/(1/Rct + Cdl*s)
// Parameters = { Rs, Rct, Cdl }
// dZ/dRs = 1
// dZ/dRct = 1 / (Rct ^ 2 * (1 / Rct + Cdl * s) ^ 2)
// dZ/dCdl = -s / (1 / Rct + Cdl * s) ^ 2

double randle_p[3] = {
    10,    100,    1e-6
}; // best parameters
double randle_z1[181] = {
    1.000025000000E+1,	1.000032000000E+1,	1.000040000000E+1,	1.000051000000E+1,	1.000064000000E+1,
    1.000080000000E+1,	1.000101000000E+1,	1.000127000000E+1,	1.000160000000E+1,	1.000201000000E+1,
    1.000253000000E+1,	1.000319000000E+1,	1.000401000000E+1,	1.000505000000E+1,	1.000636000000E+1,
    1.000801000000E+1,	1.001008000000E+1,	1.001269000000E+1,	1.001598000000E+1,	1.002012000000E+1,
    1.002532000000E+1,	1.003188000000E+1,	1.004013000000E+1,	1.005052000000E+1,	1.006359000000E+1,
    1.008004000000E+1,	1.010074000000E+1,	1.012679000000E+1,	1.015957000000E+1,	1.020080000000E+1,
    1.025266000000E+1,	1.031788000000E+1,	1.039985000000E+1,	1.050286000000E+1,	1.063225000000E+1,
    1.079465000000E+1,	1.099835000000E+1,	1.125361000000E+1,	1.157309000000E+1,	1.197237000000E+1,
    1.247045000000E+1,	1.309035000000E+1,	1.385963000000E+1,	1.481091000000E+1,	1.598206000000E+1,
    1.741610000000E+1,	1.916042000000E+1,	2.126509000000E+1,	2.377997000000E+1,	2.675031000000E+1,
    3.021083000000E+1,	3.417864000000E+1,	3.864575000000E+1,	4.357273000000E+1,	4.888533000000E+1,
    5.447573000000E+1,	6.020955000000E+1,	6.593786000000E+1,	7.151231000000E+1,	7.680010000000E+1,
    8.169568000000E+1,	8.612736000000E+1,	9.005816000000E+1,	9.348215000000E+1,	9.641799000000E+1,
    9.890140000000E+1,	1.009781000000E+2,	1.026982000000E+2,	1.041115000000E+2,	1.052653000000E+2,
    1.062021000000E+2,	1.069595000000E+2,	1.075696000000E+2,	1.080598000000E+2,	1.084527000000E+2,
    1.087670000000E+2,	1.090181000000E+2,	1.092185000000E+2,	1.093782000000E+2,	1.095055000000E+2,
    1.096068000000E+2,	1.096874000000E+2,	1.097515000000E+2,	1.098025000000E+2,	1.098431000000E+2,
    1.098753000000E+2,	1.099009000000E+2,	1.099213000000E+2,	1.099375000000E+2,	1.099503000000E+2,
    1.099605000000E+2,	1.099687000000E+2,	1.099751000000E+2,	1.099802000000E+2,	1.099843000000E+2,
    1.099875000000E+2,	1.099901000000E+2,	1.099921000000E+2,	1.099937000000E+2,	1.099950000000E+2,
    1.099961000000E+2,	1.099969000000E+2,	1.099975000000E+2,	1.099980000000E+2,	1.099984000000E+2,
    1.099988000000E+2,	1.099990000000E+2,	1.099992000000E+2,	1.099994000000E+2,	1.099995000000E+2,
    1.099996000000E+2,	1.099997000000E+2,	1.099998000000E+2,	1.099998000000E+2,	1.099998000000E+2,
    1.099999000000E+2,	1.099999000000E+2,	1.099999000000E+2,	1.099999000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,	1.100000000000E+2,
    1.100000000000E+2
}; // real part of the observed data
double randle_z2[181] = {
    -1.591545000000E-1,	-1.785742000000E-1,	-2.003634000000E-1,	-2.248112000000E-1,	-2.522420000000E-1,
    -2.830197000000E-1,	-3.175527000000E-1,	-3.562990000000E-1,	-3.997728000000E-1,	-4.485505000000E-1,
    -5.032794000000E-1,	-5.646850000000E-1,	-6.335818000000E-1,	-7.108831000000E-1,	-7.976135000000E-1,
    -8.949223000000E-1,	-1.004099000000E+0,	-1.126588000000E+0,	-1.264011000000E+0,	-1.418185000000E+0,
    -1.591146000000E+0,	-1.785179000000E+0,	-2.002838000000E+0,	-2.246988000000E+0,	-2.520832000000E+0,
    -2.827954000000E+0,	-3.172360000000E+0,	-3.558518000000E+0,	-3.991412000000E+0,	-4.476589000000E+0,
    -5.020205000000E+0,	-5.629080000000E+0,	-6.310737000000E+0,	-7.073441000000E+0,	-7.926211000000E+0,
    -8.878820000000E+0,	-9.941744000000E+0,	-1.112606000000E+1,	-1.244325000000E+1,	-1.390492000000E+1,
    -1.552231000000E+1,	-1.730562000000E+1,	-1.926309000000E+1,	-2.139968000000E+1,	-2.371542000000E+1,
    -2.620328000000E+1,	-2.884664000000E+1,	-3.161656000000E+1,	-3.446897000000E+1,	-3.734245000000E+1,
    -4.015726000000E+1,	-4.281655000000E+1,	-4.521057000000E+1,	-4.722441000000E+1,	-4.874899000000E+1,
    -4.969389000000E+1,	-4.999956000000E+1,	-4.964617000000E+1,	-4.865662000000E+1,	-4.709306000000E+1,
    -4.504772000000E+1,	-4.263052000000E+1,	-3.995632000000E+1,	-3.713415000000E+1,	-3.425974000000E+1,
    -3.141148000000E+1,	-2.864949000000E+1,	-2.601663000000E+1,	-2.354088000000E+1,	-2.123804000000E+1,
    -1.911456000000E+1,	-1.716999000000E+1,	-1.539907000000E+1,	-1.379338000000E+1,	-1.234262000000E+1,
    -1.103549000000E+1,	-9.860397000000E+0,	-8.805871000000E+0,	-7.860877000000E+0,	-7.014985000000E+0,
    -6.258478000000E+0,	-5.582389000000E+0,	-4.978510000000E+0,	-4.439371000000E+0,	-3.958201000000E+0,
    -3.528889000000E+0,	-3.145933000000E+0,	-2.804387000000E+0,	-2.499817000000E+0,	-2.228251000000E+0,
    -1.986134000000E+0,	-1.770287000000E+0,	-1.577872000000E+0,	-1.406352000000E+0,	-1.253463000000E+0,
    -1.117186000000E+0,	-9.957190000000E-1,	-8.874536000000E-1,	-7.909567000000E-1,	-7.049500000000E-1,
    -6.282937000000E-1,	-5.599719000000E-1,	-4.990787000000E-1,	-4.448067000000E-1,	-3.964360000000E-1,
    -3.533251000000E-1,	-3.149021000000E-1,	-2.806574000000E-1,	-2.501365000000E-1,	-2.229347000000E-1,
    -1.986910000000E-1,	-1.770837000000E-1,	-1.578261000000E-1,	-1.406627000000E-1,	-1.253658000000E-1,
    -1.117325000000E-1,	-9.958168000000E-2,	-8.875228000000E-2,	-7.910057000000E-2,	-7.049846000000E-2,
    -6.283183000000E-2,	-5.599893000000E-2,	-4.990910000000E-2,	-4.448154000000E-2,	-3.964421000000E-2,
    -3.533294000000E-2,	-3.149052000000E-2,	-2.806596000000E-2,	-2.501381000000E-2,	-2.229358000000E-2,
    -1.986918000000E-2,	-1.770842000000E-2,	-1.578265000000E-2,	-1.406630000000E-2,	-1.253660000000E-2,
    -1.117326000000E-2,	-9.958178000000E-3,	-8.875235000000E-3,	-7.910062000000E-3,	-7.049850000000E-3,
    -6.283185000000E-3,	-5.599895000000E-3,	-4.990911000000E-3,	-4.448155000000E-3,	-3.964422000000E-3,
    -3.533295000000E-3,	-3.149052000000E-3,	-2.806596000000E-3,	-2.501381000000E-3,	-2.229358000000E-3,
    -1.986918000000E-3,	-1.770842000000E-3,	-1.578265000000E-3,	-1.406630000000E-3,	-1.253660000000E-3,
    -1.117326000000E-3,	-9.958178000000E-4,	-8.875235000000E-4,	-7.910062000000E-4,	-7.049850000000E-4,
    -6.283185000000E-4,	-5.599895000000E-4,	-4.990911000000E-4,	-4.448155000000E-4,	-3.964422000000E-4,
    -3.533295000000E-4,	-3.149052000000E-4,	-2.806596000000E-4,	-2.501381000000E-4,	-2.229358000000E-4,
    -1.986918000000E-4,	-1.770842000000E-4,	-1.578265000000E-4,	-1.406630000000E-4,	-1.253660000000E-4,
    -1.117326000000E-4,	-9.958178000000E-5,	-8.875235000000E-5,	-7.910062000000E-5,	-7.049850000000E-5,
    -6.283185000000E-5
}; // imaginary part of the observed data
double randle_f[181] = {
    1.000000000000E+6,	8.912509000000E+5,	7.943282000000E+5,	7.079458000000E+5,	6.309573000000E+5,
    5.623413000000E+5,	5.011872000000E+5,	4.466836000000E+5,	3.981072000000E+5,	3.548134000000E+5,
    3.162278000000E+5,	2.818383000000E+5,	2.511886000000E+5,	2.238721000000E+5,	1.995262000000E+5,
    1.778279000000E+5,	1.584893000000E+5,	1.412538000000E+5,	1.258925000000E+5,	1.122018000000E+5,
    1.000000000000E+5,	8.912509000000E+4,	7.943282000000E+4,	7.079458000000E+4,	6.309573000000E+4,
    5.623413000000E+4,	5.011872000000E+4,	4.466836000000E+4,	3.981072000000E+4,	3.548134000000E+4,
    3.162278000000E+4,	2.818383000000E+4,	2.511886000000E+4,	2.238721000000E+4,	1.995262000000E+4,
    1.778279000000E+4,	1.584893000000E+4,	1.412538000000E+4,	1.258925000000E+4,	1.122018000000E+4,
    1.000000000000E+4,	8.912509000000E+3,	7.943282000000E+3,	7.079458000000E+3,	6.309573000000E+3,
    5.623413000000E+3,	5.011872000000E+3,	4.466836000000E+3,	3.981072000000E+3,	3.548134000000E+3,
    3.162278000000E+3,	2.818383000000E+3,	2.511886000000E+3,	2.238721000000E+3,	1.995262000000E+3,
    1.778279000000E+3,	1.584893000000E+3,	1.412538000000E+3,	1.258925000000E+3,	1.122018000000E+3,
    1.000000000000E+3,	8.912509000000E+2,	7.943282000000E+2,	7.079458000000E+2,	6.309573000000E+2,
    5.623413000000E+2,	5.011872000000E+2,	4.466836000000E+2,	3.981072000000E+2,	3.548134000000E+2,
    3.162278000000E+2,	2.818383000000E+2,	2.511886000000E+2,	2.238721000000E+2,	1.995262000000E+2,
    1.778279000000E+2,	1.584893000000E+2,	1.412538000000E+2,	1.258925000000E+2,	1.122018000000E+2,
    1.000000000000E+2,	8.912509000000E+1,	7.943282000000E+1,	7.079458000000E+1,	6.309573000000E+1,
    5.623413000000E+1,	5.011872000000E+1,	4.466836000000E+1,	3.981072000000E+1,	3.548134000000E+1,
    3.162278000000E+1,	2.818383000000E+1,	2.511886000000E+1,	2.238721000000E+1,	1.995262000000E+1,
    1.778279000000E+1,	1.584893000000E+1,	1.412538000000E+1,	1.258925000000E+1,	1.122018000000E+1,
    1.000000000000E+1,	8.912509000000E+0,	7.943282000000E+0,	7.079458000000E+0,	6.309573000000E+0,
    5.623413000000E+0,	5.011872000000E+0,	4.466836000000E+0,	3.981072000000E+0,	3.548134000000E+0,
    3.162278000000E+0,	2.818383000000E+0,	2.511886000000E+0,	2.238721000000E+0,	1.995262000000E+0,
    1.778279000000E+0,	1.584893000000E+0,	1.412538000000E+0,	1.258925000000E+0,	1.122018000000E+0,
    1.000000000000E+0,	8.912509000000E-1,	7.943282000000E-1,	7.079458000000E-1,	6.309573000000E-1,
    5.623413000000E-1,	5.011872000000E-1,	4.466836000000E-1,	3.981072000000E-1,	3.548134000000E-1,
    3.162278000000E-1,	2.818383000000E-1,	2.511886000000E-1,	2.238721000000E-1,	1.995262000000E-1,
    1.778279000000E-1,	1.584893000000E-1,	1.412538000000E-1,	1.258925000000E-1,	1.122018000000E-1,
    1.000000000000E-1,	8.912509000000E-2,	7.943282000000E-2,	7.079458000000E-2,	6.309573000000E-2,
    5.623413000000E-2,	5.011872000000E-2,	4.466836000000E-2,	3.981072000000E-2,	3.548134000000E-2,
    3.162278000000E-2,	2.818383000000E-2,	2.511886000000E-2,	2.238721000000E-2,	1.995262000000E-2,
    1.778279000000E-2,	1.584893000000E-2,	1.412538000000E-2,	1.258925000000E-2,	1.122018000000E-2,
    1.000000000000E-2,	8.912509000000E-3,	7.943282000000E-3,	7.079458000000E-3,	6.309573000000E-3,
    5.623413000000E-3,	5.011872000000E-3,	4.466836000000E-3,	3.981072000000E-3,	3.548134000000E-3,
    3.162278000000E-3,	2.818383000000E-3,	2.511886000000E-3,	2.238721000000E-3,	1.995262000000E-3,
    1.778279000000E-3,	1.584893000000E-3,	1.412538000000E-3,	1.258925000000E-3,	1.122018000000E-3,
    1.000000000000E-3
}; // frequency data
void randle(double *p, double *y, int m, int n, void *data)
{
    // PREMISS: the 1st half of y is real part and the other is imaginary part of the observed data
    //          y = { z1[0], z1[1], ..., z1[n/2 - 1], z2[0], z2[1], ..., z2[n/2 - 1] }
    
    register int i;
    int Ns = (int)(n / 2);

    double Rs = p[0];
    double Rct = p[1];
    double Cdl = p[2];

    double f;
    complex <double> s;
    complex <double> z;

    double *ff = (double*)data; 
    for (i = 0; i < Ns; ++i, ff++)
    {
        f = *ff;
        s = { 0.0, TwoPi * f }; // s = j * w, where angular frequency w = 2 * pi * f
        z = Rs + Rct / (1.0 + Rct * Cdl * s); //is better than Rs + 1.0 / (1.0 / Rct + Cdl * s);

        y[i] = real(z);
        y[Ns + i] = imag(z);
    }
}
void randleprime(double *p, double *jac, int m, int n, void *data)
{
    register int i;
    int Ns = (int)(n / 2);

    double Rs = p[0];
    double Rct = p[1];
    double Cdl = p[2];    

    double f;
    complex <double> s;
    complex <double> cm;
    complex <double> jac0, jac1, jac2;

    double *ff = (double*)data;
    for (i = 0; i < Ns; ++i, ff++)
    {
        f = *ff;
        s = { 0.0, TwoPi * f }; // s = j * w, where angular frequency w = 2 * pi * f
        cm = {1.0, Rct * Cdl * TwoPi * f }; // (1.0 + Rct * Cdl * s)

        jac0 = { 1.0, 0.0 };
        jac1 = 1.0 / ((1.0 + Rct * Cdl * s) * (1.0 + Rct * Cdl * s));
        jac2 = -Rct * Rct * s / ((1.0 + Rct * Cdl * s) * (1.0 + Rct * Cdl * s));

        jac[m*i] = real(jac0);
        jac[m*i + 1] = real(jac1);
        jac[m*i + 2] = real(jac2);
        jac[m*(Ns + i)] = imag(jac0);
        jac[m*(Ns + i) + 1] = imag(jac1);
        jac[m*(Ns + i) + 2] = imag(jac2);
    }
}

#pragma endregion

#pragma region Define Custom1 - L-Rs-Rp|Q

// Model Expression = L-Rs-Rp|Q
// Z = Rs + L*s + 1/(1/Rp + Qy*s^Qa)
// Parameters = { L, Rs, Rp, Qy, Qa }
// dZ/dL = s
// dZ/dRs = 1
// dZ/dRp = 1/(Rp^2*(1/Rp + Qy*s^Qa)^2)
// dZ/dQy = -s^Qa/(1/Rp + Qy*s^Qa)^2
// dZ/dQa = -(Qy*s^Qa*ln(s))/(1/Rp + Qy*s^Qa)^2

double custom1_p[5] = {
    1e-6,    0.1,    0.1,   2,  0.8
}; // best parameters
double custom1_z1[181] = {
    1.000006E-1,	1.000006E-1,	1.000007E-1,	1.000007E-1,	1.000008E-1,
    1.000009E-1,	1.000010E-1,	1.000011E-1,	1.000012E-1,	1.000013E-1,
    1.000014E-1,	1.000016E-1,	1.000017E-1,	1.000019E-1,	1.000020E-1,
    1.000022E-1,	1.000025E-1,	1.000027E-1,	1.000030E-1,	1.000032E-1,
    1.000036E-1,	1.000039E-1,	1.000043E-1,	1.000047E-1,	1.000051E-1,
    1.000056E-1,	1.000062E-1,	1.000068E-1,	1.000074E-1,	1.000081E-1,
    1.000089E-1,	1.000098E-1,	1.000107E-1,	1.000118E-1,	1.000129E-1,
    1.000142E-1,	1.000155E-1,	1.000170E-1,	1.000187E-1,	1.000205E-1,
    1.000225E-1,	1.000246E-1,	1.000270E-1,	1.000296E-1,	1.000325E-1,
    1.000356E-1,	1.000391E-1,	1.000429E-1,	1.000470E-1,	1.000516E-1,
    1.000566E-1,	1.000620E-1,	1.000681E-1,	1.000747E-1,	1.000819E-1,
    1.000899E-1,	1.000986E-1,	1.001082E-1,	1.001188E-1,	1.001303E-1,
    1.001431E-1,	1.001571E-1,	1.001724E-1,	1.001893E-1,	1.002079E-1,
    1.002283E-1,	1.002508E-1,	1.002755E-1,	1.003027E-1,	1.003327E-1,
    1.003657E-1,	1.004021E-1,	1.004422E-1,	1.004865E-1,	1.005353E-1,
    1.005892E-1,	1.006488E-1,	1.007147E-1,	1.007875E-1,	1.008682E-1,
    1.009575E-1,	1.010566E-1,	1.011666E-1,	1.012887E-1,	1.014244E-1,
    1.015754E-1,	1.017435E-1,	1.019309E-1,	1.021401E-1,	1.023736E-1,
    1.026347E-1,	1.029269E-1,	1.032541E-1,	1.036208E-1,	1.040321E-1,
    1.044938E-1,	1.050122E-1,	1.055945E-1,	1.062486E-1,	1.069834E-1,
    1.078084E-1,	1.087341E-1,	1.097717E-1,	1.109330E-1,	1.122300E-1,
    1.136753E-1,	1.152807E-1,	1.170577E-1,	1.190161E-1,	1.211637E-1,
    1.235054E-1,	1.260421E-1,	1.287705E-1,	1.316819E-1,	1.347618E-1,
    1.379898E-1,	1.413401E-1,	1.447815E-1,	1.482792E-1,	1.517956E-1,
    1.552925E-1,	1.587323E-1,	1.620803E-1,	1.653055E-1,	1.683819E-1,
    1.712895E-1,	1.740139E-1,	1.765466E-1,	1.788840E-1,	1.810275E-1,
    1.829820E-1,	1.847552E-1,	1.863572E-1,	1.877991E-1,	1.890932E-1,
    1.902516E-1,	1.912867E-1,	1.922102E-1,	1.930332E-1,	1.937661E-1,
    1.944187E-1,	1.949995E-1,	1.955166E-1,	1.959772E-1,	1.963875E-1,
    1.967533E-1,	1.970797E-1,	1.973711E-1,	1.976316E-1,	1.978646E-1,
    1.980733E-1,	1.982603E-1,	1.984280E-1,	1.985787E-1,	1.987141E-1,
    1.988359E-1,	1.989456E-1,	1.990445E-1,	1.991336E-1,	1.992141E-1,
    1.992868E-1,	1.993525E-1,	1.994120E-1,	1.994658E-1,	1.995145E-1,
    1.995587E-1,	1.995987E-1,	1.996350E-1,	1.996680E-1,	1.996979E-1,
    1.997250E-1,	1.997497E-1,	1.997721E-1,	1.997925E-1,	1.998111E-1,
    1.998279E-1,	1.998433E-1,	1.998572E-1,	1.998699E-1,	1.998815E-1,
    1.998920E-1
}; // real part of the observed data
double custom1_z2[181] = {
    6.283184E+0,	5.599893E+0,	4.990909E+0,	4.448152E+0,	3.964419E+0,
    3.533292E+0,	3.149049E+0,	2.806592E+0,	2.501378E+0,	2.229354E+0,
    1.986913E+0,	1.770837E+0,	1.578260E+0,	1.406624E+0,	1.253654E+0,
    1.117319E+0,	9.958102E-1,	8.875152E-1,	7.909971E-1,	7.049750E-1,
    6.283076E-1,	5.599775E-1,	4.990780E-1,	4.448010E-1,	3.964264E-1,
    3.533122E-1,	3.148862E-1,	2.806388E-1,	2.501153E-1,	2.229108E-1,
    1.986643E-1,	1.770541E-1,	1.577935E-1,	1.406268E-1,	1.253264E-1,
    1.116891E-1,	9.953408E-2,	8.870005E-2,	7.904327E-2,	7.043563E-2,
    6.276292E-2,	5.592337E-2,	4.982624E-2,	4.439068E-2,	3.954460E-2,
    3.522372E-2,	3.137077E-2,	2.793466E-2,	2.486986E-2,	2.213575E-2,
    1.969614E-2,	1.751871E-2,	1.557466E-2,	1.383827E-2,	1.228661E-2,
    1.089919E-2,	9.657723E-3,	8.545856E-3,	7.548980E-3,	6.654022E-3,
    5.849278E-3,	5.124256E-3,	4.469542E-3,	3.876675E-3,	3.338036E-3,
    2.846752E-3,	2.396605E-3,	1.981953E-3,	1.597659E-3,	1.239026E-3,
    9.017381E-4,	5.818070E-4,	2.755262E-4,	-2.057413E-5,	-3.097671E-4,
    -5.951649E-4,	-8.797530E-4,	-1.166420E-3,	-1.457987E-3,	-1.757232E-3,
    -2.066917E-3,	-2.389805E-3,	-2.728684E-3,	-3.086382E-3,	-3.465784E-3,
    -3.869844E-3,	-4.301592E-3,	-4.764143E-3,	-5.260695E-3,	-5.794529E-3,
    -6.368991E-3,	-6.987479E-3,	-7.653410E-3,	-8.370181E-3,	-9.141111E-3,
    -9.969366E-3,	-1.085787E-2,	-1.180918E-2,	-1.282534E-2,	-1.390773E-2,
    -1.505682E-2,	-1.627195E-2,	-1.755109E-2,	-1.889046E-2,	-2.028431E-2,
    -2.172455E-2,	-2.320043E-2,	-2.469837E-2,	-2.620173E-2,	-2.769081E-2,
    -2.914302E-2,	-3.053323E-2,	-3.183441E-2,	-3.301854E-2,	-3.405777E-2,
    -3.492573E-2,	-3.559903E-2,	-3.605862E-2,	-3.629105E-2,	-3.628940E-2,
    -3.605377E-2,	-3.559124E-2,	-3.491540E-2,	-3.404544E-2,	-3.300486E-2,
    -3.182010E-2,	-3.051905E-2,	-2.912975E-2,	-2.767924E-2,	-2.619262E-2,
    -2.469248E-2,	-2.319850E-2,	-2.172729E-2,	-2.029244E-2,	-1.890467E-2,
    -1.757210E-2,	-1.630053E-2,	-1.509374E-2,	-1.395385E-2,	-1.288159E-2,
    -1.187658E-2,	-1.093756E-2,	-1.006261E-2,	-9.249328E-3,	-8.494969E-3,
    -7.796565E-3,	-7.151023E-3,	-6.555204E-3,	-6.005977E-3,	-5.500269E-3,
    -5.035095E-3,	-4.607585E-3,	-4.214997E-3,	-3.854730E-3,	-3.524327E-3,
    -3.221483E-3,	-2.944034E-3,	-2.689964E-3,	-2.457395E-3,	-2.244583E-3,
    -2.049912E-3,	-1.871886E-3,	-1.709123E-3,	-1.560351E-3,	-1.424394E-3,
    -1.300172E-3,	-1.186691E-3,	-1.083040E-3,	-9.883783E-4,	-9.019385E-4,
    -8.230152E-4,	-7.509621E-4,	-6.851874E-4,	-6.251491E-4,	-5.703511E-4,
    -5.203395E-4,	-4.746991E-4,	-4.330503E-4,	-3.950460E-4,	-3.603688E-4,
    -3.287289E-4
}; // imaginary part of the observed data
double custom1_f[181] = {
    1.000000E+6,	8.912509E+5,	7.943282E+5,	7.079458E+5,	6.309573E+5,
    5.623413E+5,	5.011872E+5,	4.466836E+5,	3.981072E+5,	3.548134E+5,
    3.162278E+5,	2.818383E+5,	2.511886E+5,	2.238721E+5,	1.995262E+5,
    1.778279E+5,	1.584893E+5,	1.412538E+5,	1.258925E+5,	1.122018E+5,
    1.000000E+5,	8.912509E+4,	7.943282E+4,	7.079458E+4,	6.309573E+4,
    5.623413E+4,	5.011872E+4,	4.466836E+4,	3.981072E+4,	3.548134E+4,
    3.162278E+4,	2.818383E+4,	2.511886E+4,	2.238721E+4,	1.995262E+4,
    1.778279E+4,	1.584893E+4,	1.412538E+4,	1.258925E+4,	1.122018E+4,
    1.000000E+4,	8.912509E+3,	7.943282E+3,	7.079458E+3,	6.309573E+3,
    5.623413E+3,	5.011872E+3,	4.466836E+3,	3.981072E+3,	3.548134E+3,
    3.162278E+3,	2.818383E+3,	2.511886E+3,	2.238721E+3,	1.995262E+3,
    1.778279E+3,	1.584893E+3,	1.412538E+3,	1.258925E+3,	1.122018E+3,
    1.000000E+3,	8.912509E+2,	7.943282E+2,	7.079458E+2,	6.309573E+2,
    5.623413E+2,	5.011872E+2,	4.466836E+2,	3.981072E+2,	3.548134E+2,
    3.162278E+2,	2.818383E+2,	2.511886E+2,	2.238721E+2,	1.995262E+2,
    1.778279E+2,	1.584893E+2,	1.412538E+2,	1.258925E+2,	1.122018E+2,
    1.000000E+2,	8.912509E+1,	7.943282E+1,	7.079458E+1,	6.309573E+1,
    5.623413E+1,	5.011872E+1,	4.466836E+1,	3.981072E+1,	3.548134E+1,
    3.162278E+1,	2.818383E+1,	2.511886E+1,	2.238721E+1,	1.995262E+1,
    1.778279E+1,	1.584893E+1,	1.412538E+1,	1.258925E+1,	1.122018E+1,
    1.000000E+1,	8.912509E+0,	7.943282E+0,	7.079458E+0,	6.309573E+0,
    5.623413E+0,	5.011872E+0,	4.466836E+0,	3.981072E+0,	3.548134E+0,
    3.162278E+0,	2.818383E+0,	2.511886E+0,	2.238721E+0,	1.995262E+0,
    1.778279E+0,	1.584893E+0,	1.412538E+0,	1.258925E+0,	1.122018E+0,
    1.000000E+0,	8.912509E-1,	7.943282E-1,	7.079458E-1,	6.309573E-1,
    5.623413E-1,	5.011872E-1,	4.466836E-1,	3.981072E-1,	3.548134E-1,
    3.162278E-1,	2.818383E-1,	2.511886E-1,	2.238721E-1,	1.995262E-1,
    1.778279E-1,	1.584893E-1,	1.412538E-1,	1.258925E-1,	1.122018E-1,
    1.000000E-1,	8.912509E-2,	7.943282E-2,	7.079458E-2,	6.309573E-2,
    5.623413E-2,	5.011872E-2,	4.466836E-2,	3.981072E-2,	3.548134E-2,
    3.162278E-2,	2.818383E-2,	2.511886E-2,	2.238721E-2,	1.995262E-2,
    1.778279E-2,	1.584893E-2,	1.412538E-2,	1.258925E-2,	1.122018E-2,
    1.000000E-2,	8.912509E-3,	7.943282E-3,	7.079458E-3,	6.309573E-3,
    5.623413E-3,	5.011872E-3,	4.466836E-3,	3.981072E-3,	3.548134E-3,
    3.162278E-3,	2.818383E-3,	2.511886E-3,	2.238721E-3,	1.995262E-3,
    1.778279E-3,	1.584893E-3,	1.412538E-3,	1.258925E-3,	1.122018E-3,
    1.000000E-3
}; // frequency data
void custom1(double *p, double *y, int m, int n, void *data)
{
    // PREMISS: the 1st half of y is real part and the other is imaginary part of the observed data
    //          y = { z1[0], z1[1], ..., z1[n/2 - 1], z2[0], z2[1], ..., z2[n/2 - 1] }

    register int i;
    int Ns = (int)(n / 2);

    double L = p[0];
    double Rs = p[1];
    double Rp = p[2];
    double Qy = p[3];
    double Qa = p[4];

    double f;
    complex <double> s, cm, z;

    double *ff = (double*)data;
    for (i = 0; i < Ns; ++i, ff++)
    {
        f = *ff;
        s = { 0.0, TwoPi * f }; // s = j * w, where angular frequency w = 2 * pi * f
        cm = Rp * Qy * pow(s, Qa);
        z = s * L + Rs + Rp / (1.0 + cm);

        y[i] = real(z);
        y[Ns + i] = imag(z);
    }
}
void custom1prime(double *p, double *jac, int m, int n, void *data)
{
    register int i;
    int Ns = (int)(n / 2);

    double L = p[0];
    double Rs = p[1];
    double Rp = p[2];
    double Qy = p[3];
    double Qa = p[4];

    double f;
    complex <double> s, cm, cmSq;
    complex <double> jac0, jac1, jac2, jac3, jac4;

    double *ff = (double*)data;
    for (i = 0; i < Ns; ++i, ff++)
    {
        f = *ff;
        s = { 0.0, TwoPi * f }; // s = j * w, where angular frequency w = 2 * pi * f
        cm = Rp * Qy * pow(s, Qa);
        cmSq = (1.0 + cm) * (1.0 + cm);

        jac0 = s;
        jac1 = 1.0;
        jac2 = 1.0 / cmSq;
        jac3 = -Rp * Rp * pow(s, Qa) / cmSq;
        jac4 = -Rp * cm * log(s) / cmSq;

        jac[m*i] = real(jac0);
        jac[m*i + 1] = real(jac1);
        jac[m*i + 2] = real(jac2);
        jac[m*i + 3] = real(jac3);
        jac[m*i + 4] = real(jac4);
        jac[m*(Ns + i)] = imag(jac0);
        jac[m*(Ns + i) + 1] = imag(jac1);
        jac[m*(Ns + i) + 2] = imag(jac2);
        jac[m*(Ns + i) + 3] = imag(jac3);
        jac[m*(Ns + i) + 4] = imag(jac4);
    }
}

#pragma endregion

#pragma region Define Custom2 - L-Rs-Rp|Q-W

// Model Expression = L-Rs-Rp|Q-W
// Z = Rs + 1/(W*sqrt(s)) + L*s + 1/(1/Rp + Qy*s^Qa)
// Parameters = { L, Rs, Rp, Qy, Qa, W }
// dZ/dL = s
// dZ/dRs = 1
// dZ/dRp = 1/(Rp^2*(1/Rp + Qy*s^Qa)^2)
// dZ/dQy = -s^Qa/(1/Rp + Qy*s^Qa)^2
// dZ/dQa = -(Qy*s^Qa*ln(s))/(1/Rp + Qy*s^Qa)^2
// dZ/dW  = -1/(W^2*sqrt(s))

double custom2_p[6] = {
    0.001,    0.1,    0.1,   2,  0.8,    1.0
}; // best parameters
double custom2_z1[81] = {
    1.090637E-1,	1.096063E-1,	1.101815E-1,	1.107915E-1,	1.114383E-1,
    1.121241E-1,	1.128515E-1,	1.136229E-1,	1.144410E-1,	1.153087E-1,
    1.162291E-1,	1.172054E-1,	1.182412E-1,	1.193401E-1,	1.205061E-1,
    1.217433E-1,	1.230564E-1,	1.244500E-1,	1.259292E-1,	1.274997E-1,
    1.291670E-1,	1.309376E-1,	1.328181E-1,	1.348157E-1,	1.369380E-1,
    1.391933E-1,	1.415905E-1,	1.441390E-1,	1.468491E-1,	1.497318E-1,
    1.527991E-1,	1.560636E-1,	1.595394E-1,	1.632412E-1,	1.671853E-1,
    1.713890E-1,	1.758712E-1,	1.806521E-1,	1.857537E-1,	1.911995E-1,
    1.970146E-1,	2.032262E-1,	2.098627E-1,	2.169547E-1,	2.245340E-1,
    2.326337E-1,	2.412879E-1,	2.505312E-1,	2.603985E-1,	2.709235E-1,
    2.821389E-1,	2.940753E-1,	3.067603E-1,	3.202183E-1,	3.344696E-1,
    3.495311E-1,	3.654160E-1,	3.821347E-1,	3.996965E-1,	4.181103E-1,
    4.373873E-1,	4.575423E-1,	4.785959E-1,	5.005757E-1,	5.235182E-1,
    5.474690E-1,	5.724834E-1,	5.986268E-1,	6.259741E-1,	6.546094E-1,
    6.846253E-1,	7.161228E-1,	7.492103E-1,	7.840034E-1,	8.206247E-1,
    8.592038E-1,	8.998768E-1,	9.427868E-1,	9.880843E-1,	1.035927E+0,
    1.086481E+0
}; // real part of the observed data
double custom2_z2[81] = {
    6.273831E+0,	5.589970E+0,	4.980381E+0,	4.436981E+0,	3.952565E+0,
    3.520712E+0,	3.135699E+0,	2.792424E+0,	2.486339E+0,	2.213392E+0,
    1.969969E+0,	1.752850E+0,	1.559163E+0,	1.386349E+0,	1.232126E+0,
    1.094459E+0,	9.715346E-1,	8.617343E-1,	7.636154E-1,	6.758913E-1,
    5.974138E-1,	5.271587E-1,	4.642118E-1,	4.077572E-1,	3.570663E-1,
    3.114884E-1,	2.704418E-1,	2.334067E-1,	1.999183E-1,	1.695602E-1,
    1.419597E-1,	1.167829E-1,	9.372993E-2,	7.253173E-2,	5.294639E-2,
    3.475628E-2,	1.776532E-2,	1.796755E-3,	-1.330894E-2,	-2.769582E-2,
    -4.149400E-2,	-5.482101E-2,	-6.778289E-2,	-8.047517E-2,	-9.298370E-2,
    -1.053853E-1,	-1.177485E-1,	-1.301340E-1,	-1.425952E-1,	-1.551793E-1,
    -1.679273E-1,	-1.808757E-1,	-1.940573E-1,	-2.075026E-1,	-2.212415E-1,
    -2.353049E-1,	-2.497267E-1,	-2.645454E-1,	-2.798061E-1,	-2.955613E-1,
    -3.118717E-1,	-3.288069E-1,	-3.464450E-1,	-3.648720E-1,	-3.841807E-1,
    -4.044698E-1,	-4.258426E-1,	-4.484062E-1,	-4.722705E-1,	-4.975474E-1,
    -5.243509E-1,	-5.527970E-1,	-5.830037E-1,	-6.150915E-1,	-6.491838E-1,
    -6.854081E-1,	-7.238958E-1,	-7.647838E-1,	-8.082148E-1,	-8.543382E-1,
    -9.033109E-1
}; // imaginary part of the observed data
double custom2_f[81] = {
    1.000000E+3,	8.912509E+2,	7.943282E+2,	7.079458E+2,	6.309573E+2,
    5.623413E+2,	5.011872E+2,	4.466836E+2,	3.981072E+2,	3.548134E+2,
    3.162278E+2,	2.818383E+2,	2.511886E+2,	2.238721E+2,	1.995262E+2,
    1.778279E+2,	1.584893E+2,	1.412538E+2,	1.258925E+2,	1.122018E+2,
    1.000000E+2,	8.912509E+1,	7.943282E+1,	7.079458E+1,	6.309573E+1,
    5.623413E+1,	5.011872E+1,	4.466836E+1,	3.981072E+1,	3.548134E+1,
    3.162278E+1,	2.818383E+1,	2.511886E+1,	2.238721E+1,	1.995262E+1,
    1.778279E+1,	1.584893E+1,	1.412538E+1,	1.258925E+1,	1.122018E+1,
    1.000000E+1,	8.912509E+0,	7.943282E+0,	7.079458E+0,	6.309573E+0,
    5.623413E+0,	5.011872E+0,	4.466836E+0,	3.981072E+0,	3.548134E+0,
    3.162278E+0,	2.818383E+0,	2.511886E+0,	2.238721E+0,	1.995262E+0,
    1.778279E+0,	1.584893E+0,	1.412538E+0,	1.258925E+0,	1.122018E+0,
    1.000000E+0,	8.912509E-1,	7.943282E-1,	7.079458E-1,	6.309573E-1,
    5.623413E-1,	5.011872E-1,	4.466836E-1,	3.981072E-1,	3.548134E-1,
    3.162278E-1,	2.818383E-1,	2.511886E-1,	2.238721E-1,	1.995262E-1,
    1.778279E-1,	1.584893E-1,	1.412538E-1,	1.258925E-1,	1.122018E-1,
    1.000000E-1
}; // frequency data
void custom2(double *p, double *y, int m, int n, void *data)
{
    // PREMISS: the 1st half of y is real part and the other is imaginary part of the observed data
    //          y = { z1[0], z1[1], ..., z1[n/2 - 1], z2[0], z2[1], ..., z2[n/2 - 1] }

    register int i;
    int Ns = (int)(n / 2);

    double L = p[0];
    double Rs = p[1];
    double Rp = p[2];
    double Qy = p[3];
    double Qa = p[4];
    double W = p[5];

    double f;
    complex <double> s, cm, z;
    complex <double> oneOverSqrtj2Pi(OneOverTwoSqrtPi, -OneOverTwoSqrtPi); // 1/sqrt(2 pi j)

    double *ff = (double*)data;
    for (i = 0; i < Ns; ++i, ff++)
    {
        f = *ff;
        s = { 0.0, TwoPi * f }; // s = j * w, where angular frequency w = 2 * pi * f
        
        cm = Rp * Qy * pow(s, Qa);
        z = s * L + Rs + Rp / (1.0 + cm) + oneOverSqrtj2Pi / (W * sqrt(f));

        y[i] = real(z);
        y[Ns + i] = imag(z);
    }
}
void custom2prime(double *p, double *jac, int m, int n, void *data)
{
    register int i;
    int Ns = (int)(n / 2);

    double L = p[0];
    double Rs = p[1];
    double Rp = p[2];
    double Qy = p[3];
    double Qa = p[4];
    double W = p[5];

    double f;
    complex <double> s, cm, cmSq;
    complex <double> jac0, jac1, jac2, jac3, jac4, jac5;

    complex <double> oneOverSqrtj2Pi(OneOverTwoSqrtPi, -OneOverTwoSqrtPi); // 1/sqrt(2 pi j)

    double *ff = (double*)data;
    for (i = 0; i < Ns; ++i, ff++)
    {
        f = *ff;
        s = { 0.0, TwoPi * f }; // s = j * w, where angular frequency w = 2 * pi * f
        cm = Rp * Qy * pow(s, Qa);
        cmSq = (1.0 + cm) * (1.0 + cm);

        jac0 = s;
        jac1 = 1.0;
        jac2 = 1.0 / cmSq;
        jac3 = -Rp * Rp * pow(s, Qa) / cmSq;
        jac4 = -Rp * cm * log(s) / cmSq;
        jac5 = -oneOverSqrtj2Pi / (W * W * sqrt(f));

        jac[m*i] = real(jac0);
        jac[m*i + 1] = real(jac1);
        jac[m*i + 2] = real(jac2);
        jac[m*i + 3] = real(jac3);
        jac[m*i + 4] = real(jac4);
        jac[m*i + 5] = real(jac5);
        jac[m*(Ns + i)] = imag(jac0);
        jac[m*(Ns + i) + 1] = imag(jac1);
        jac[m*(Ns + i) + 2] = imag(jac2);
        jac[m*(Ns + i) + 3] = imag(jac3);
        jac[m*(Ns + i) + 4] = imag(jac4);
        jac[m*(Ns + i) + 5] = imag(jac5);
    }
}

#pragma endregion

#pragma region Define Custom3 - Ls-Rs-R1|Q1-(R2-W)|Q2

// Model Expression = L-Rs-Rp|Q-W
// Z = Rs + Ls*s + 1/(1/R1 + Q1y*s^Q1a) + 1/(1/(R2 + 1/(W*sqrt(s))) + Q2y*s^Q2a)
// Parameters = { L, Rs, R1, Q1y, Q1a, R2, W, Q2y, Q2a}
//dZ/dLs = s
//dZ/dRs = 1
//dZ/dR1 = 1 / (R1 ^ 2 * (1 / R1 + Q1y * s^Q1a) ^ 2)
//dZ/dQ1y = -s ^ Q1a / (1 / R1 + Q1y * s^Q1a) ^ 2
//dZ/dQ1a = -(Q1y*s^Q1a*ln(s)) / (1 / R1 + Q1y * s^Q1a) ^ 2
//dZ/dR2 = 1 / ((R2 + 1 / (W*sqrt(s))) ^ 2 * (1 / (R2 + 1 / (W*sqrt(s))) + Q2y * s^Q2a) ^ 2)
//dZ/dW = -1 / (W ^ 2 * (R2 + 1 / (W*sqrt(s))) ^ 2 * sqrt(s)*(1 / (R2 + 1 / (W*sqrt(s))) + Q2y * s^Q2a) ^ 2)
//dZ/dQ2y = -s ^ Q2a / (1 / (R2 + 1 / (W*sqrt(s))) + Q2y * s^Q2a) ^ 2
//dZ/dQ2a = -(Q2y*s^Q2a*ln(s)) / (1 / (R2 + 1 / (W*sqrt(s))) + Q2y * s^Q2a) ^ 2

double custom3_p[9] = {
    1E-5,    1,    1,   0.1,    0.9,    0.1,    1,  2,  0.65 
}; // best parameters
double custom3_z1[141] = {
    1.000275000000E+0,	1.000298000000E+0,	1.000324000000E+0,	1.000353000000E+0,	1.000383000000E+0,
    1.000417000000E+0,	1.000453000000E+0,	1.000493000000E+0,	1.000537000000E+0,	1.000584000000E+0,
    1.000636000000E+0,	1.000693000000E+0,	1.000754000000E+0,	1.000822000000E+0,	1.000895000000E+0,
    1.000976000000E+0,	1.001064000000E+0,	1.001161000000E+0,	1.001266000000E+0,	1.001382000000E+0,
    1.001508000000E+0,	1.001647000000E+0,	1.001799000000E+0,	1.001966000000E+0,	1.002149000000E+0,
    1.002350000000E+0,	1.002571000000E+0,	1.002814000000E+0,	1.003082000000E+0,	1.003376000000E+0,
    1.003701000000E+0,	1.004060000000E+0,	1.004456000000E+0,	1.004894000000E+0,	1.005379000000E+0,
    1.005916000000E+0,	1.006513000000E+0,	1.007176000000E+0,	1.007914000000E+0,	1.008738000000E+0,
    1.009657000000E+0,	1.010687000000E+0,	1.011841000000E+0,	1.013138000000E+0,	1.014599000000E+0,
    1.016247000000E+0,	1.018112000000E+0,	1.020227000000E+0,	1.022631000000E+0,	1.025369000000E+0,
    1.028497000000E+0,	1.032077000000E+0,	1.036184000000E+0,	1.040903000000E+0,	1.046338000000E+0,
    1.052605000000E+0,	1.059839000000E+0,	1.068196000000E+0,	1.077853000000E+0,	1.089008000000E+0,
    1.101878000000E+0,	1.116702000000E+0,	1.133729000000E+0,	1.153216000000E+0,	1.175412000000E+0,
    1.200543000000E+0,	1.228795000000E+0,	1.260287000000E+0,	1.295045000000E+0,	1.332984000000E+0,
    1.373880000000E+0,	1.417371000000E+0,	1.462952000000E+0,	1.510001000000E+0,	1.557812000000E+0,
    1.605640000000E+0,	1.652755000000E+0,	1.698492000000E+0,	1.742294000000E+0,	1.783733000000E+0,
    1.822531000000E+0,	1.858550000000E+0,	1.891777000000E+0,	1.922308000000E+0,	1.950316000000E+0,
    1.976034000000E+0,	1.999724000000E+0,	2.021668000000E+0,	2.042149000000E+0,	2.061444000000E+0,
    2.079814000000E+0,	2.097506000000E+0,	2.114747000000E+0,	2.131749000000E+0,	2.148705000000E+0,
    2.165792000000E+0,	2.183176000000E+0,	2.201011000000E+0,	2.219443000000E+0,	2.238611000000E+0,
    2.258649000000E+0,	2.279687000000E+0,	2.301856000000E+0,	2.325284000000E+0,	2.350103000000E+0,
    2.376446000000E+0,	2.404451000000E+0,	2.434260000000E+0,	2.466021000000E+0,	2.499891000000E+0,
    2.536031000000E+0,	2.574615000000E+0,	2.615823000000E+0,	2.659850000000E+0,	2.706898000000E+0,
    2.757184000000E+0,	2.810941000000E+0,	2.868412000000E+0,	2.929860000000E+0,	2.995563000000E+0,
    3.065817000000E+0,	3.140938000000E+0,	3.221264000000E+0,	3.307154000000E+0,	3.398991000000E+0,
    3.497183000000E+0,	3.602167000000E+0,	3.714406000000E+0,	3.834397000000E+0,	3.962667000000E+0,
    4.099781000000E+0,	4.246338000000E+0,	4.402979000000E+0,	4.570388000000E+0,	4.749291000000E+0,
    4.940466000000E+0,	5.144740000000E+0,	5.362995000000E+0,	5.596170000000E+0,	5.845267000000E+0,
    6.111355000000E+0
}; // real part of the observed data
double custom3_z2[141] = {
    6.275211000000E-1,	5.591152000000E-1,	4.981325000000E-1,	4.437641000000E-1,	3.952890000000E-1,
    3.520643000000E-1,	3.135169000000E-1,	2.791359000000E-1,	2.484655000000E-1,	2.210994000000E-1,
    1.966752000000E-1,	1.748694000000E-1,	1.553935000000E-1,	1.379899000000E-1,	1.224287000000E-1,
    1.085043000000E-1,	9.603317000000E-2,	8.485103000000E-2,	7.481084000000E-2,	6.578088000000E-2,
    5.764295000000E-2,	5.029085000000E-2,	4.362899000000E-2,	3.757111000000E-2,	3.203920000000E-2,
    2.696245000000E-2,	2.227635000000E-2,	1.792185000000E-2,	1.384464000000E-2,	9.994404000000E-3,
    6.324259000000E-3,	2.790125000000E-3,	-6.497850000000E-4,	-4.035476000000E-3,	-7.405632000000E-3,
    -1.079806000000E-2,	-1.425011000000E-2,	-1.779908000000E-2,	-2.148257000000E-2,	-2.533891000000E-2,
    -2.940746000000E-2,	-3.372898000000E-2,	-3.834596000000E-2,	-4.330290000000E-2,	-4.864665000000E-2,
    -5.442659000000E-2,	-6.069486000000E-2,	-6.750651000000E-2,	-7.491950000000E-2,	-8.299463000000E-2,
    -9.179531000000E-2,	-1.013870000000E-1,	-1.118366000000E-1,	-1.232111000000E-1,	-1.355760000000E-1,
    -1.489931000000E-1,	-1.635174000000E-1,	-1.791935000000E-1,	-1.960502000000E-1,	-2.140947000000E-1,
    -2.333052000000E-1,	-2.536227000000E-1,	-2.749414000000E-1,	-2.970997000000E-1,	-3.198710000000E-1,
    -3.429569000000E-1,	-3.659845000000E-1,	-3.885091000000E-1,	-4.100250000000E-1,	-4.299860000000E-1,
    -4.478353000000E-1,	-4.630440000000E-1,	-4.751546000000E-1,	-4.838234000000E-1,	-4.888560000000E-1,
    -4.902289000000E-1,	-4.880947000000E-1,	-4.827680000000E-1,	-4.746958000000E-1,	-4.644181000000E-1,
    -4.525243000000E-1,	-4.396117000000E-1,	-4.262515000000E-1,	-4.129641000000E-1,	-4.002033000000E-1,
    -3.883507000000E-1,	-3.777162000000E-1,	-3.685430000000E-1,	-3.610163000000E-1,	-3.552729000000E-1,
    -3.514104000000E-1,	-3.494968000000E-1,	-3.495785000000E-1,	-3.516870000000E-1,	-3.558451000000E-1,
    -3.620714000000E-1,	-3.703838000000E-1,	-3.808031000000E-1,	-3.933548000000E-1,	-4.080710000000E-1,
    -4.249918000000E-1,	-4.441667000000E-1,	-4.656547000000E-1,	-4.895260000000E-1,	-5.158614000000E-1,
    -5.447541000000E-1,	-5.763090000000E-1,	-6.106441000000E-1,	-6.478901000000E-1,	-6.881917000000E-1,
    -7.317075000000E-1,	-7.786110000000E-1,	-8.290910000000E-1,	-8.833522000000E-1,	-9.416159000000E-1,
    -1.004121000000E+0,	-1.071125000000E+0,	-1.142905000000E+0,	-1.219757000000E+0,	-1.302000000000E+0,
    -1.389975000000E+0,	-1.484046000000E+0,	-1.584604000000E+0,	-1.692065000000E+0,	-1.806875000000E+0,
    -1.929508000000E+0,	-2.060471000000E+0,	-2.200305000000E+0,	-2.349586000000E+0,	-2.508928000000E+0,
    -2.678985000000E+0,	-2.860454000000E+0,	-3.054077000000E+0,	-3.260644000000E+0,	-3.480998000000E+0,
    -3.716033000000E+0,	-3.966704000000E+0,	-4.234025000000E+0,	-4.519076000000E+0,	-4.823005000000E+0,
    -5.147035000000E+0
}; // imaginary part of the observed data
double custom3_f[141] = {
    1.000000000000E+4,	8.912509000000E+3,	7.943282000000E+3,	7.079458000000E+3,	6.309573000000E+3,
    5.623413000000E+3,	5.011872000000E+3,	4.466836000000E+3,	3.981072000000E+3,	3.548134000000E+3,
    3.162278000000E+3,	2.818383000000E+3,	2.511886000000E+3,	2.238721000000E+3,	1.995262000000E+3,
    1.778279000000E+3,	1.584893000000E+3,	1.412538000000E+3,	1.258925000000E+3,	1.122018000000E+3,
    1.000000000000E+3,	8.912509000000E+2,	7.943282000000E+2,	7.079458000000E+2,	6.309573000000E+2,
    5.623413000000E+2,	5.011872000000E+2,	4.466836000000E+2,	3.981072000000E+2,	3.548134000000E+2,
    3.162278000000E+2,	2.818383000000E+2,	2.511886000000E+2,	2.238721000000E+2,	1.995262000000E+2,
    1.778279000000E+2,	1.584893000000E+2,	1.412538000000E+2,	1.258925000000E+2,	1.122018000000E+2,
    1.000000000000E+2,	8.912509000000E+1,	7.943282000000E+1,	7.079458000000E+1,	6.309573000000E+1,
    5.623413000000E+1,	5.011872000000E+1,	4.466836000000E+1,	3.981072000000E+1,	3.548134000000E+1,
    3.162278000000E+1,	2.818383000000E+1,	2.511886000000E+1,	2.238721000000E+1,	1.995262000000E+1,
    1.778279000000E+1,	1.584893000000E+1,	1.412538000000E+1,	1.258925000000E+1,	1.122018000000E+1,
    1.000000000000E+1,	8.912509000000E+0,	7.943282000000E+0,	7.079458000000E+0,	6.309573000000E+0,
    5.623413000000E+0,	5.011872000000E+0,	4.466836000000E+0,	3.981072000000E+0,	3.548134000000E+0,
    3.162278000000E+0,	2.818383000000E+0,	2.511886000000E+0,	2.238721000000E+0,	1.995262000000E+0,
    1.778279000000E+0,	1.584893000000E+0,	1.412538000000E+0,	1.258925000000E+0,	1.122018000000E+0,
    1.000000000000E+0,	8.912509000000E-1,	7.943282000000E-1,	7.079458000000E-1,	6.309573000000E-1,
    5.623413000000E-1,	5.011872000000E-1,	4.466836000000E-1,	3.981072000000E-1,	3.548134000000E-1,
    3.162278000000E-1,	2.818383000000E-1,	2.511886000000E-1,	2.238721000000E-1,	1.995262000000E-1,
    1.778279000000E-1,	1.584893000000E-1,	1.412538000000E-1,	1.258925000000E-1,	1.122018000000E-1,
    1.000000000000E-1,	8.912509000000E-2,	7.943282000000E-2,	7.079458000000E-2,	6.309573000000E-2,
    5.623413000000E-2,	5.011872000000E-2,	4.466836000000E-2,	3.981072000000E-2,	3.548134000000E-2,
    3.162278000000E-2,	2.818383000000E-2,	2.511886000000E-2,	2.238721000000E-2,	1.995262000000E-2,
    1.778279000000E-2,	1.584893000000E-2,	1.412538000000E-2,	1.258925000000E-2,	1.122018000000E-2,
    1.000000000000E-2,	8.912509000000E-3,	7.943282000000E-3,	7.079458000000E-3,	6.309573000000E-3,
    5.623413000000E-3,	5.011872000000E-3,	4.466836000000E-3,	3.981072000000E-3,	3.548134000000E-3,
    3.162278000000E-3,	2.818383000000E-3,	2.511886000000E-3,	2.238721000000E-3,	1.995262000000E-3,
    1.778279000000E-3,	1.584893000000E-3,	1.412538000000E-3,	1.258925000000E-3,	1.122018000000E-3,
    1.000000000000E-3
}; // frequency data
void custom3(double *p, double *y, int m, int n, void *data)
{
    // PREMISS: the 1st half of y is real part and the other is imaginary part of the observed data
    //          y = { z1[0], z1[1], ..., z1[n/2 - 1], z2[0], z2[1], ..., z2[n/2 - 1] }

    register int i;
    int Ns = (int)(n / 2);

    double Ls = p[0];
    double Rs = p[1];
    double R1 = p[2];
    double Q1y = p[3];
    double Q1a = p[4];
    double R2 = p[5];
    double W = p[6];
    double Q2y = p[7];
    double Q2a = p[8];    

    complex <double> s;
    complex <double> z;

    double *ff = (double*)data;
    for (i = 0; i < Ns; ++i, ff++)
    {
        double f = *ff;
        s = { 0.0, TwoPi * f }; // s = j * w, where angular frequency w = 2 * pi * f
        z = Rs + Ls * s + R1 / (R1 * Q1y * pow(s, Q1a) + 1.0) + (R2 * sqrt(s) * W + 1.0) / (W * R2 * Q2y * pow(s, Q2a) * sqrt(s) + W * sqrt(s) + Q2y * pow(s, Q2a));

        y[i] = real(z);
        y[Ns + i] = imag(z);
    }
}
void custom3prime(double *p, double *jac, int m, int n, void *data)
{
    register int i;
    int Ns = (int)(n / 2);

    double Ls = p[0];
    double Rs = p[1];
    double R1 = p[2];
    double Q1y = p[3];
    double Q1a = p[4];
    double R2 = p[5];
    double W = p[6];
    double Q2y = p[7];
    double Q2a = p[8];

    double f;
    complex <double> s;
    complex <double> jac0, jac1, jac2, jac3, jac4, jac5, jac6, jac7, jac8, jac9;

    double *ff = (double*)data;
    for (i = 0; i < Ns; ++i, ff++)
    {
        f = *ff;
        s = { 0.0, TwoPi * f }; // s = j * w, where angular frequency w = 2 * pi * f
        
        jac0 = s;
        jac1 = 1.0;
        jac2 = 1.0 / pow(R1 * Q1y * pow(s, Q1a) + 1.0, 2);
        jac3 = -(R1 * R1 * pow(s, Q1a)) / pow(R1 * Q1y * pow(s, Q1a) + 1.0, 2);
        jac4 = -(R1 * R1 * Q1y * pow(s, Q1a) * log(s)) / pow(R1 * Q1y * pow(s, Q1a) + 1.0, 2);
        jac5 = (s * W * W) / pow(R2 * W * Q2y * pow(s, Q2a) * sqrt(s) + Q2y * pow(s, Q2a) + sqrt(s) * W, 2);
        jac6 = -sqrt(s) / pow(R2 * W * Q2y * pow(s, Q2a) * sqrt(s) + Q2y * pow(s, Q2a) + sqrt(s) * W, 2);
        jac7 = -(pow(s, Q2a) * pow(R2 * sqrt(s) * W + 1.0, 2)) / pow(R2 * W * Q2y * pow(s, Q2a) * sqrt(s) + Q2y * pow(s, Q2a) + sqrt(s) * W, 2);
        jac8 = -(Q2y * pow(s, Q2a) * log(s) * pow(R2 * sqrt(s) * W + 1.0, 2)) / pow(R2 * W * Q2y * pow(s, Q2a) * sqrt(s) + Q2y * pow(s, Q2a) + sqrt(s) * W, 2);

        jac[m*i] = real(jac0);
        jac[m*i + 1] = real(jac1);
        jac[m*i + 2] = real(jac2);
        jac[m*i + 3] = real(jac3);
        jac[m*i + 4] = real(jac4);
        jac[m*i + 5] = real(jac5);
        jac[m*i + 6] = real(jac6);
        jac[m*i + 7] = real(jac7);
        jac[m*i + 8] = real(jac8);
        jac[m*(Ns + i)] = imag(jac0);
        jac[m*(Ns + i) + 1] = imag(jac1);
        jac[m*(Ns + i) + 2] = imag(jac2);
        jac[m*(Ns + i) + 3] = imag(jac3);
        jac[m*(Ns + i) + 4] = imag(jac4);
        jac[m*(Ns + i) + 5] = imag(jac5);
        jac[m*(Ns + i) + 6] = imag(jac6);
        jac[m*(Ns + i) + 7] = imag(jac7);
        jac[m*(Ns + i) + 8] = imag(jac8);
    }
}

#pragma endregion

int main()
{
	int i, ret;

	int m; // parameter vector dimension
	int n; // measurement vector dimension

	double p[40]; // initial parameter estimates
    double lb[40]; // lower bound of parameters
    //double ub[40]; // upper bound of parameters
    double x[40]; // measurement vector
    
	double opts[LM_OPTS_SZ];
	opts[0] = LM_INIT_MU;
	opts[1] = 1E-15;
	opts[2] = 1E-15;
	opts[3] = 1E-20;
	opts[4] = LM_DIFF_DELTA; // relevant only if the finite difference jacobian version is used 

	double info[LM_INFO_SZ]; // information regarding the minimization

    int maxiteration = 1000; // max iteration

    //
	// 1. Rosenbrock
    //

	m = 2; n = 2;
    for (i = 0; i < n; i++) x[i] = 0.0;

    //
    // 6.1 analytic Jacobian
    //
    p[0] = -1.2; p[1] = 1.0;
    ret = dlevmar_der(rosenbrock, rosenbrockprime, p, x, m, n, 10 * maxiteration, opts, info, NULL, NULL, NULL);

	printf("Results for Rosenberg -  with analytic jacobian\n");
	printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
	for (i = 0; i < m; ++i)
		printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", rosenbrock_p[i]);
	printf("\n\nMinimization info:\n");
	for (i = 0; i < LM_INFO_SZ; ++i)
		printf("%g ", info[i]);

	printf("\n");
	printf("\n");
	printf("-----------------------------------------\n");
	printf("\n");

    //
    // 6.2 finite difference approximated Jacobian
    //
    p[0] = 0.8; p[1] = 0.64;
    ret = dlevmar_dif(rosenbrock, p, x, m, n, 10 * maxiteration, opts, info, NULL, NULL, NULL);

    printf("Results for Rosenberg - with finite difference approximated Jacobian \n");
    printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
    for (i = 0; i < m; ++i)
        printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", rosenbrock_p[i]);
    printf("\n\nMinimization info:\n");
    for (i = 0; i < LM_INFO_SZ; ++i)
        printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

    //
	// 2. Norris - Linear Regression
    //

	m = 2; n = 36;
	p[0] = 1.0; p[1] = 1.0;
	
	ret = dlevmar_der(norris, norrisprime, p, norris_y, m, n, maxiteration, opts, info, NULL, NULL, NULL);

	printf("Results for Norris - with analytic jacobian\n");
	printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
	for (i = 0; i < m; ++i)
		printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", norris_p[i]);
	printf("\n\nMinimization info:\n");
	for (i = 0; i < LM_INFO_SZ; ++i)
		printf("%g ", info[i]);
	
	printf("\n");
	printf("\n");
	printf("-----------------------------------------\n");
	printf("\n");

	//
    // 3. Lanczos1 - Non-linear Regression
    //

	m = 6; n = 24;
	p[0] = 1.2; p[1] = 0.3; p[2] = 5.6; p[3] = 5.5; p[4] = 6.5; p[5] = 7.6; // initail values

	ret = dlevmar_dif(lanczos1, p, lanczos1_y, m, n, maxiteration, opts, info, NULL, NULL, lanczos1_x);

	printf("Results for Lanczos1\n");
	printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
	for (i = 0; i < m; ++i)
		printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", lanczos1_p[i]);
	printf("\n\nMinimization info:\n");
	for (i = 0; i < LM_INFO_SZ; ++i)
		printf("%g ", info[i]);
	
	printf("\n");
	printf("\n");
	printf("-----------------------------------------\n");
	printf("\n");

    //
	// 4. Thurber - Non-linear Regression
    //

	m = 7; n = 37;
	p[0] = 1000; p[1] = 1000; p[2] = 400; p[3] = 40; p[4] = 0.7; p[5] = 0.3; p[6] = 0.03;

	ret = dlevmar_dif(thurber, p, thurber_y, m, n, maxiteration, opts, info, NULL, NULL, thurber_x);

	printf("Results for Thurber\n");
	printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
	for (i = 0; i < m; ++i)
		printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", thurber_p[i]);
	printf("\n\nMinimization info:\n");
	for (i = 0; i < LM_INFO_SZ; ++i)
		printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

    //
    // 5. Rat43 - Non-linear Regression
    //

    m = 4; n = 15;
    p[0] = 100; p[1] = 10; p[2] = 1; p[3] = 1; // initial values
        
    ret = dlevmar_dif(rat43, p, rat43_y, m, n, maxiteration, opts, info, NULL, NULL, rat43_x);

    printf("Results for Rat43\n");
    printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
    for (i = 0; i < m; ++i)
        printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", rat43_p[i]);
    printf("\n\nMinimization info:\n");
    for (i = 0; i < LM_INFO_SZ; ++i)
        printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

    //
    // 6. Randle - Complex non-linear Regression
    //

    m = 3; n = 181;
    
    double randle_y[362];
    memcpy(randle_y, randle_z1, n * sizeof(double));
    memcpy(&randle_y[n], randle_z2, n * sizeof(double));

    lb[0] = 1e-20; lb[1] = 1e-20; lb[2] = 1e-20; // set lower bound

    //
    // 6.1 analytic Jacobian
    //
    p[0] = 10.0; p[1] = 10.0; p[2] = 1e-6; // initial values   
    ret = dlevmar_bc_der(randle, randleprime, p, randle_y, m, 2 * n, lb, NULL, NULL, maxiteration, opts, info, NULL, NULL, randle_f);

    printf("Results for Randle - with analytic Jacobian\n");
    printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
    for (i = 0; i < m; ++i)
        printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", randle_p[i]);
    printf("\n\nMinimization info:\n");
    for (i = 0; i < LM_INFO_SZ; ++i)
        printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

    //
    // 6.2 finite difference approximated Jacobian
    //
    p[0] = 10.0; p[1] = 10.0; p[2] = 1.0e-6; // initial values 
    ret = dlevmar_bc_dif(randle, p, randle_y, m, 2 * n, lb, NULL, NULL, maxiteration, opts, info, NULL, NULL, randle_f);

    printf("Results for Randle - with finite difference approximated Jacobian \n");
    printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
    for (i = 0; i < m; ++i)
        printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", randle_p[i]);
    printf("\n\nMinimization info:\n");
    for (i = 0; i < LM_INFO_SZ; ++i)
        printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

    //
    // 7. Custom1, L-Rs-Rp|Q - Complex non-linear Regression
    //

    m = 5; n = 181;

    double custom1_y[362];
    memcpy(custom1_y, custom1_z1, n * sizeof(double));
    memcpy(&custom1_y[n], custom1_z2, n * sizeof(double));

    lb[0] = 1e-10; lb[1] = 1e-10; lb[2] = 1e-10; lb[3] = 1e-10; lb[4] = 1e-10;// set lower bound

    //
    // 7.1 analytic Jacobian
    //
    p[0] = 1e-6; p[1] = 0.181; p[2] = 7.981; p[3] = 0.032; p[4] = 0.666; // initial values  
    ret = dlevmar_bc_der(custom1, custom1prime, p, custom1_y, m, 2 * n, lb, NULL, NULL, maxiteration, opts, info, NULL, NULL, custom1_f);

    printf("Results for L-Rs-Rp|Q - with analytic Jacobian\n");
    printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
    for (i = 0; i < m; ++i)
        printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", custom1_p[i]);
    printf("\n\nMinimization info:\n");
    for (i = 0; i < LM_INFO_SZ; ++i)
        printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

    //
    // 7.2 finite difference approximated Jacobian
    //
    p[0] = 1e-6; p[1] = 0.181; p[2] = 7.981; p[3] = 0.032; p[4] = 0.666; // initial values   
    ret = dlevmar_bc_dif(custom1, p, custom1_y, m, 2 * n, lb, NULL, NULL, maxiteration, opts, info, NULL, NULL, custom1_f);

    printf("Results for L-Rs-Rp|Q - with finite difference approximated Jacobian \n");
    printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
    for (i = 0; i < m; ++i)
        printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", custom1_p[i]);
    printf("\n\nMinimization info:\n");
    for (i = 0; i < LM_INFO_SZ; ++i)
        printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

    //
    // 8. Custom2, L-Rs-Rp|Q-W - Complex non-linear Regression
    //

    m = 6; n = 81;

    double custom2_y[162];
    memcpy(custom2_y, custom2_z1, n * sizeof(double));
    memcpy(&custom2_y[n], custom2_z2, n * sizeof(double));

    lb[0] = 1e-10; lb[1] = 1e-10; lb[2] = 1e-10; lb[3] = 1e-10; lb[4] = 1e-10; lb[5] = 1e-10;// set lower bound

    //
    // 8.1 analytic Jacobian
    //
    p[0] = 2e-3; p[1] = 0.08; p[2] = 0.210; p[3] = 2.272; p[4] = 0.7; p[5] = 1.4; // initial values 
    ret = dlevmar_bc_der(custom2, custom2prime, p, custom2_y, m, 2 * n, lb, NULL, NULL, maxiteration, opts, info, NULL, NULL, custom2_f);

    printf("Results for L-Rs-Rp|Q-W - with analytic Jacobian\n");
    printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
    for (i = 0; i < m; ++i)
        printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", custom2_p[i]);
    printf("\n\nMinimization info:\n");
    for (i = 0; i < LM_INFO_SZ; ++i)
        printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

    //
    // 8.2 finite difference approximated Jacobian
    //
    p[0] = 2e-3; p[1] = 0.08; p[2] = 0.210; p[3] = 2.272; p[4] = 0.7; p[5] = 1.4; // initial values
    ret = dlevmar_bc_dif(custom2, p, custom2_y, m, 2 * n, lb, NULL, NULL, maxiteration, opts, info, NULL, NULL, custom2_f);

    printf("Results for L-Rs-Rp|Q-W - with finite difference approximated Jacobian \n");
    printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
    for (i = 0; i < m; ++i)
        printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", custom2_p[i]);
    printf("\n\nMinimization info:\n");
    for (i = 0; i < LM_INFO_SZ; ++i)
        printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

    //
    // 9. Custom3, Ls-Rs-R1|Q1-(R2-W)|Q2 - Complex non-linear Regression
    //

    m = 9; n = 141;

    double custom3_y[282];
    memcpy(custom3_y, custom3_z1, n * sizeof(double));
    memcpy(&custom3_y[n], custom3_z2, n * sizeof(double));

    lb[0] = 1e-10; lb[1] = 1e-10; lb[2] = 1e-10; lb[3] = 1e-10; lb[4] = 1e-10; // set lower bound
    lb[5] = 1e-10; lb[6] = 1e-10; lb[7] = 1e-10; lb[8] = 1e-10;

    //
    // 9.1 analytic Jacobian
    //
    p[0] = 2e-5; p[1] = 1.1; p[2] = 0.9; p[3] = 0.09; p[4] = 0.88;
    p[5] = 0.2; p[6] = 1.2; p[7] = 2.1; p[8] = 0.6; // initial values 
    ret = dlevmar_bc_der(custom3, custom3prime, p, custom3_y, m, 2 * n, lb, NULL, NULL, maxiteration, opts, info, NULL, NULL, custom3_f);

    printf("Results for Ls-Rs-R1|Q1-(R2-W)|Q2 - with analytic Jacobian\n");
    printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
    for (i = 0; i < m; ++i)
        printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", custom3_p[i]);
    printf("\n\nMinimization info:\n");
    for (i = 0; i < LM_INFO_SZ; ++i)
        printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

    //
    // 9.2 finite difference approximated Jacobian
    //
    p[0] = 2e-5; p[1] = 1.1; p[2] = 0.9; p[3] = 0.09; p[4] = 0.88;
    p[5] = 0.2; p[6] = 1.2; p[7] = 2.1; p[8] = 0.6; // initial values 
    ret = dlevmar_bc_dif(custom3, p, custom3_y, m, 2 * n, lb, NULL, NULL, maxiteration, opts, info, NULL, NULL, custom3_f);

    printf("Results for Ls-Rs-R1|Q1-(R2-W)|Q2 - with finite difference approximated Jacobian \n");
    printf("Levenberg-Marquardt returned %d in %g iter, reason %g\nSolution: ", ret, info[5], info[6]);
    for (i = 0; i < m; ++i)
        printf("%12.7g ", p[i]);
    printf("\nExpected: ");
    for (i = 0; i < m; ++i)
        printf("%12.7g ", custom3_p[i]);
    printf("\n\nMinimization info:\n");
    for (i = 0; i < LM_INFO_SZ; ++i)
        printf("%g ", info[i]);

    printf("\n");
    printf("\n");
    printf("-----------------------------------------\n");
    printf("\n");

	return 0;
}
